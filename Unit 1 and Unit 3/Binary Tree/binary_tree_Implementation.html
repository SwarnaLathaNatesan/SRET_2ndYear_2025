<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Binary Tree Implementation — Python</title>
  <style>
    body{font-family:Inter,system-ui,Arial;background:#f7f9fb;color:#1a1a1a;line-height:1.6;margin:0;padding:24px}
    h1,h2,h3{color:#0b4b5a}
    pre{background:#0f1720;color:#e6eef0;border-radius:8px;padding:16px;overflow:auto;white-space:pre-wrap}
    code{font-family:Menlo,Monaco,"Courier New",monospace;font-size:14px}
    .section{margin-bottom:32px}
    .output{background:#f1f5f9;border-left:4px solid #0b4b5a;padding:12px;border-radius:6px;font-family:monospace;white-space:pre-wrap}
  </style>
</head>
<body>
  <div class="container">
    <h1>Binary Tree Implementation in Python</h1>
    <p>This document provides a simple implementation of a Binary Search Tree (BST) in Python with insertion, searching, and different traversal methods.</p>

    <div class="section">
      <h2>Basic Binary Tree Implementation</h2>
      <pre><code>class TreeNode:
    def __init__(self, value):
        self.value = value
        self.left = None
        self.right = None

class BinaryTree:
    def __init__(self):
        self.root = None
    
    def insert(self, value):
        """Insert a new value into the binary tree"""
        if self.root is None:
            self.root = TreeNode(value)
        else:
            self._insert_recursive(self.root, value)
    
    def _insert_recursive(self, node, value):
        if value < node.value:
            if node.left is None:
                node.left = TreeNode(value)
            else:
                self._insert_recursive(node.left, value)
        else:
            if node.right is None:
                node.right = TreeNode(value)
            else:
                self._insert_recursive(node.right, value)
    
    def search(self, value):
        return self._search_recursive(self.root, value)
    
    def _search_recursive(self, node, value):
        if node is None:
            return False
        if node.value == value:
            return True
        elif value &lt; node.value:
            return self._search_recursive(node.left, value)
        else:
            return self._search_recursive(node.right, value)
    
    def inorder_traversal(self):
        result = []
        self._inorder_recursive(self.root, result)
        return result
    
    def _inorder_recursive(self, node, result):
        if node:
            self._inorder_recursive(node.left, result)
            result.append(node.value)
            self._inorder_recursive(node.right, result)
    
    def preorder_traversal(self):
        result = []
        self._preorder_recursive(self.root, result)
        return result
    
    def _preorder_recursive(self, node, result):
        if node:
            result.append(node.value)
            self._preorder_recursive(node.left, result)
            self._preorder_recursive(node.right, result)
    
    def postorder_traversal(self):
        result = []
        self._postorder_recursive(self.root, result)
        return result
    
    def _postorder_recursive(self, node, result):
        if node:
            self._postorder_recursive(node.left, result)
            self._postorder_recursive(node.right, result)
            result.append(node.value)

# Example usage
values = [50, 30, 70, 20, 40, 60, 80]
tree = BinaryTree()
for value in values:
    tree.insert(value)

print("In-order:", tree.inorder_traversal())
print("Pre-order:", tree.preorder_traversal())
print("Post-order:", tree.postorder_traversal())
print("Search 40:", tree.search(40))
print("Search 100:", tree.search(100))</code></pre>
    </div>

    <div class="section">
      <h2>Output</h2>
      <div class="output">
In-order traversal: [20, 30, 40, 50, 60, 70, 80]<br>
Pre-order traversal: [50, 30, 20, 40, 70, 60, 80]<br>
Post-order traversal: [20, 40, 30, 60, 80, 70, 50]

Search results:<br>
Search for 40: True<br>
Search for 100: False

Tree structure:

        50
       /  \
      30   70
     / \   / \
    20 40 60 80
      </div>
    </div>

    <div class="section">
      <h2>Even Simpler Version</h2>
      <pre><code>class Node:
    def __init__(self, key):
        self.left = None
        self.right = None
        self.val = key

# Create a simple binary tree manually
root = Node(1)
root.left = Node(2)
root.right = Node(3)
root.left.left = Node(4)
root.left.right = Node(5)

# Simple traversal function
def inorder_traversal(node):
    if node:
        inorder_traversal(node.left)
        print(node.val, end=' ')
        inorder_traversal(node.right)

print("In-order traversal:")
inorder_traversal(root)  # Output: 4 2 5 1 3</code></pre>
    </div>

    <div class="section">
      <h2>Key Concepts</h2>
      <ul>
        <li><strong>TreeNode</strong>: Represents each node with value, left, and right pointers</li>
        <li><strong>Insertion</strong>: Values less than current node go left, others go right</li>
        <li><strong>Traversals</strong>:
          <ul>
            <li>In-order: Left → Root → Right (sorted order)</li>
            <li>Pre-order: Root → Left → Right</li>
            <li>Post-order: Left → Right → Root</li>
          </ul>
        </li>
        <li><strong>Search</strong>: Recursively navigates the tree to find values</li>
      </ul>
      <p>This binary tree implementation follows the BST (Binary Search Tree) property where <em>left child &lt; parent &lt; right child</em>, making searching efficient (O(log n) on average).</p>
    </div>
  </div>
</body>
</html>
