<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Segment Tree — Build & Query Step Visualizer</title>
<style>
  :root{
    --bg:#071028; --panel:#071427; --accent:#22d3ee;
    --node-bg: linear-gradient(135deg,#3b82f6,#22d3ee);
    --text:#e6eef8; --visited:#f59e0b; --contrib:#10b981; --skip:#94a3b8;
    --build-color: #8b5cf6;
  }
  body{
    margin:0; min-height:100vh; background:linear-gradient(140deg,var(--bg) 0%, #031025 100%);
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, Arial; color:var(--text);
    padding:20px; box-sizing:border-box;
  }
  .wrap{ max-width:1200px; margin:0 auto; }

  header{ text-align:center; margin-bottom:10px; }
  h1{ margin:6px 0; font-size:1.4rem; color:#eaf6ff; }
  p.lead{ margin:0; opacity:.9; color:#cfeffd; }

  .controls{ display:flex; gap:10px; flex-wrap:wrap; margin:12px 0; align-items:center; }
  input[type="text"], input[type="number"]{
    padding:8px 10px; border-radius:8px; border:0; outline:none; min-width:140px;
    background:#071226; color:var(--text);
  }
  button.btn{
    background:linear-gradient(90deg,#2563eb,#22d3ee); border:none; color:#012; padding:8px 12px;
    border-radius:8px; font-weight:700; cursor:pointer;
  }
  button.ghost{ background:transparent; color:var(--text); border:1px solid rgba(255,255,255,0.06); }
  .panel{ background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border-radius:12px; padding:10px; margin-bottom:12px; box-shadow:0 10px 40px rgba(2,6,23,0.6); }

  .array-display{ display:flex; gap:8px; flex-wrap:wrap; justify-content:center; padding:10px 6px; }
  .cell{ min-width:60px; height:60px; background:linear-gradient(135deg,#1e3a8a,#2563eb); color:white;
    border-radius:8px; display:flex; flex-direction:column; align-items:center; justify-content:center; font-weight:700; }
  .cell small{ opacity:.9; font-weight:700; font-size:12px; }

  .layout{ display:grid; grid-template-columns: 1fr; gap:12px; }
  @media(min-width:920px){ .layout{ grid-template-columns: 1fr 1fr; } }

  .tree-area{ position:relative; padding:12px; overflow:auto; border-radius:10px; min-height:320px; }
  #svg-lines{ position:absolute; inset:0; pointer-events:none; z-index:0; }
  .tree{ display:flex; flex-direction:column; align-items:center; gap:18px; padding:18px 8px 40px; z-index:1; min-width:600px; }
  .level{ display:flex; gap:16px; align-items:flex-start; justify-content:center; }
  .node{
    position:relative; min-width:100px; padding:8px 10px; background:var(--node-bg); color:#001018;
    border-radius:10px; text-align:center; box-shadow:0 10px 30px rgba(2,6,23,0.6); cursor:pointer; z-index:2;
    transition: transform .12s ease, box-shadow .12s ease, background .12s ease;
  }
  .node .range{ font-weight:800; font-size:13px; color:#04233f; }
  .node .value{ font-weight:900; font-size:18px; margin-top:6px; color:#001018; }
  .node .idx{ font-size:11px; opacity:0.8; margin-top:4px; color:#021827; }

  .hidden{ opacity:0.12; filter:grayscale(.2); }
  .build-show{ background: linear-gradient(135deg,#8b5cf6,#7c3aed) !important; color:#04101f; }
  .visited{ background:linear-gradient(135deg,#f59e0b,#fbbf24) !important; color:#061016; box-shadow:0 12px 36px rgba(245,158,11,0.12); }
  .partial{ background:linear-gradient(135deg,#fbbf24,#f59e0b) !important; color:#051016; box-shadow:0 12px 36px rgba(245,158,11,0.10); }
  .contrib{ background:linear-gradient(135deg,#10b981,#059669) !important; color:#01120f; box-shadow:0 12px 36px rgba(16,185,129,0.12); }
  .skip{ background:linear-gradient(135deg,#9aa6b2,#94a3b8) !important; color:#021218; box-shadow:0 8px 20px rgba(2,6,23,0.12); }

  .controls-steps{ display:flex; gap:8px; align-items:center; margin-top:8px; flex-wrap:wrap; }

  .steps{ margin-top:10px; background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01)); padding:10px; border-radius:8px; color:#dff6ff; font-weight:600; min-height:84px; }
  .steps small{ display:block; color:#bfeffd; font-weight:500; margin-top:6px; }

  .legend{ display:flex; gap:12px; align-items:center; justify-content:center; margin-top:8px; }
  .legend .dot{ width:14px; height:14px; border-radius:4px; display:inline-block; vertical-align:middle; }

  footer{ text-align:center; opacity:.7; margin-top:10px; font-size:13px; }

  @media (max-width:720px){
    .node{ min-width:64px; padding:6px; font-size:14px; }
    .tree{ min-width:unset; }
    .level{ gap:8px; flex-wrap:wrap; }
  }
</style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>Segment Tree — Build & Query Visualizer</h1>
    <p class="lead">Step-by-step building and query mapping — array & tree synchronized</p>
  </header>

  <div class="panel">
    <div class="controls">
      <input id="array-input" type="text" value="1,3,5,7,9,11" placeholder="Enter array like: 1,3,5,7" />
      <button class="btn" id="build-btn">Build Tree (generate DOM)</button>

      <button class="ghost" id="start-build-steps">Start Build Steps</button>

      <label style="display:flex; gap:6px; align-items:center;">
        <input id="q-l" type="number" placeholder="l" style="width:72px" />
        <input id="q-r" type="number" placeholder="r" style="width:72px" />
      </label>
      <button class="ghost" id="record-query">Record Query (recursive)</button>

      <div style="margin-left:auto; display:flex; gap:8px; align-items:center;">
        <button class="ghost" id="prev-step" disabled>&larr; Prev</button>
        <button class="ghost" id="next-step" disabled>Next &rarr;</button>
        <button class="ghost" id="play-pause" disabled>Play</button>
        <button class="ghost" id="reset-all">Reset</button>
      </div>
    </div>

    <div class="array-display panel" id="array-display"></div>
  </div>

  <div class="layout">
    <div class="panel tree-area" id="tree-panel">
      <svg id="svg-lines" xmlns="http://www.w3.org/2000/svg"></svg>
      <div class="tree" id="tree-root"></div>

      <div class="legend">
        <div style="display:flex; gap:8px; align-items:center;"><span class="dot" style="background:var(--build-color)"></span><span>Build (show node)</span></div>
        <div style="display:flex; gap:8px; align-items:center;"><span class="dot" style="background:var(--visited)"></span><span>Visited / checking</span></div>
        <div style="display:flex; gap:8px; align-items:center;"><span class="dot" style="background:var(--contrib)"></span><span>Full overlap → contributes</span></div>
        <div style="display:flex; gap:8px; align-items:center;"><span class="dot" style="background:var(--skip)"></span><span>No overlap → skip</span></div>
      </div>
    </div>

    <div class="panel">
      <div class="steps" id="step-log">
        <div><strong>Steps / explanation:</strong></div>
        <small>Build the tree and then record a query to step through both phases.</small>
      </div>
    </div>
  </div>

  <footer>Interactive visualization — shows mapping between query ranges and node ranges</footer>
</div>

<script>
(() => {
  // DOM refs
  const arrayInput = document.getElementById('array-input');
  const buildBtn = document.getElementById('build-btn');
  const startBuildStepsBtn = document.getElementById('start-build-steps');
  const arrayDisplay = document.getElementById('array-display');
  const treeRoot = document.getElementById('tree-root');
  const svg = document.getElementById('svg-lines');
  const recordQueryBtn = document.getElementById('record-query');
  const ql = document.getElementById('q-l');
  const qr = document.getElementById('q-r');
  const prevBtn = document.getElementById('prev-step');
  const nextBtn = document.getElementById('next-step');
  const playBtn = document.getElementById('play-pause');
  const resetBtn = document.getElementById('reset-all');
  const stepLog = document.getElementById('step-log');

  let currentArray = [];
  let tree = null; // array-based tree
  let eventList = [];
  let currentStep = -1;
  let playInterval = null;
  let visitedCounts = {}, contribCounts = {}, buildShown = {};
  const defaultSpeed = 500;

  // helpers
  function parseArrayInput(text){
    return text.split(',').map(s=>s.trim()).filter(s=>s!=='').map(Number).filter(n=>!Number.isNaN(n));
  }

  function renderArray(arr){
    arrayDisplay.innerHTML = '';
    arr.forEach((v,i) => {
      const d = document.createElement('div');
      d.className = 'cell';
      d.id = `cell-${i}`;
      d.innerHTML = `<small>Idx ${i}</small><div style="margin-top:6px; font-weight:900;">${v}</div>`;
      arrayDisplay.appendChild(d);
    });
  }

  // Build tree array and create DOM nodes (hidden initially)
  function buildSegmentTree(arr){
    const n = arr.length;
    const size = Math.pow(2, Math.ceil(Math.log2(Math.max(1,n))));
    const treeArr = new Array(2*size);
    for (let i=0;i<2*size;i++) treeArr[i] = { value:0, start:-1, end:-1 };
    for (let i=0;i<n;i++) treeArr[size+i] = { value: arr[i], start:i, end:i };
    for (let i=n;i<size;i++) treeArr[size+i] = { value:0, start:i, end:i };
    for (let i=size-1;i>0;i--){
      const L = treeArr[2*i], R = treeArr[2*i+1];
      treeArr[i] = {
        value: (L.value||0) + (R.value||0),
        start: (L.start!==-1 ? L.start : R.start),
        end: (R.end!==-1 ? R.end : L.end)
      };
    }
    treeArr.size = size;
    treeArr.realLength = n;
    return treeArr;
  }

  function createTreeDOM(treeArr){
    treeRoot.innerHTML = ''; svg.innerHTML = '';
    buildShown = {}; visitedCounts = {}; contribCounts = {};
    const levels = Math.ceil(Math.log2(treeArr.size)) + 1;
    const levelContainers = [];
    for (let lv=0; lv<levels; lv++){
      const lvDiv = document.createElement('div');
      lvDiv.className = 'level';
      treeRoot.appendChild(lvDiv);
      levelContainers.push(lvDiv);
    }
    for (let i=1;i<treeArr.length;i++){
      if (treeArr[i] && treeArr[i].start !== -1){
        const nodeEl = document.createElement('div');
        nodeEl.className = 'node hidden';
        nodeEl.id = `node-${i}`;
        nodeEl.dataset.index = i;
        nodeEl.innerHTML = `<div class="range">[${treeArr[i].start}, ${treeArr[i].end}]</div>
                            <div class="value">${treeArr[i].value}</div>
                            <div class="idx">idx ${i}</div>`;
        const level = Math.floor(Math.log2(i));
        levelContainers[level].appendChild(nodeEl);
      }
    }
    requestAnimationFrame(drawAllConnectors);
  }

  function drawAllConnectors(){
    svg.innerHTML = '';
    const nodes = document.querySelectorAll('.node');
    const coords = {};
    const panelRect = document.getElementById('tree-panel').getBoundingClientRect();
    nodes.forEach(n => {
      const r = n.getBoundingClientRect();
      const cx = r.left + r.width/2 - panelRect.left;
      const cy = r.top + r.height/2 - panelRect.top;
      coords[n.id] = {cx, cy, el: n};
    });
    Object.keys(coords).forEach(id => {
      const idx = Number(id.replace('node-',''));
      const parentIdx = Math.floor(idx/2);
      if (parentIdx >= 1){
        const parentId = 'node-' + parentIdx;
        if (coords[parentId]){
          const p = coords[parentId], c = coords[id];
          const path = makeConnectorPath(p.cx, p.cy + 18, c.cx, c.cy - 18);
          svg.appendChild(path);
        }
      }
    });
  }

  function makeConnectorPath(x1,y1,x2,y2){
    const ns = "http://www.w3.org/2000/svg";
    const path = document.createElementNS(ns,'path');
    const dx = x2-x1, dy = y2-y1;
    const mx = x1 + dx*0.5, my = y1 + dy*0.45;
    const d = `M ${x1} ${y1} Q ${mx} ${my} ${x2} ${y2}`;
    path.setAttribute('d', d);
    path.setAttribute('stroke','rgba(150,200,255,0.95)');
    path.setAttribute('fill','none');
    path.setAttribute('stroke-width','3');
    path.setAttribute('stroke-linecap','round');
    return path;
  }

  // BUILD events generator (recursive): creates events that reveal nodes and highlight array slice
  function generateBuildEvents(treeArr){
    const events = [];
    function rec(idx){
      const node = treeArr[idx];
      if (!node || node.start === -1) return;
      // event: show node, highlight array slice [l,r]
      events.push({ type:'build-show', idx, l: node.start, r: node.end, value: node.value });
      // if leaf, done
      if (node.start === node.end) return;
      const mid = Math.floor((node.start + node.end) / 2);
      // show splitting info
      events.push({ type:'build-split', idx, l: node.start, mid, r: node.end });
      rec(idx*2);
      rec(idx*2+1);
      // event: done node (optional)
      events.push({ type:'build-done', idx, l: node.start, r: node.end, value: node.value });
    }
    // root idx is 1
    rec(1);
    return events;
  }

  // QUERY events generator (recursive), with clear overlap states
  function generateQueryEvents(treeArr, Lq, Rq){
    const events = [];
    let result = 0;
    function rec(idx){
      const node = treeArr[idx];
      if (!node || node.start === -1) return;
      // check overlap
      const a = node.start, b = node.end;
      if (Rq < a || Lq > b){
        // no overlap
        events.push({ type:'query-no', idx, nodeRange:[a,b] });
        return;
      }
      if (Lq <= a && b <= Rq){
        // full overlap
        events.push({ type:'query-full', idx, nodeRange:[a,b], value: node.value });
        result += node.value;
        return;
      }
      // partial
      events.push({ type:'query-partial', idx, nodeRange:[a,b] });
      rec(idx*2);
      rec(idx*2+1);
    }
    rec(1);
    return { events, result };
  }

  // Step runner applies or undoes events
  function resetVisualization(){
    stopPlay();
    document.querySelectorAll('.node').forEach(n => {
      n.classList.remove('hidden','build-show','visited','partial','contrib','skip');
      // initially hide nodes until build steps reveal them
      n.classList.add('hidden');
    });
    // reset array highlights
    document.querySelectorAll('.cell').forEach(c => c.style.filter = 'none');
    stepLog.innerHTML = `<div><strong>Steps / explanation:</strong></div><small>Build the tree and then record a query to step through both phases.</small>`;
    visitedCounts = {}; contribCounts = {}; buildShown = {};
    eventList = []; currentStep = -1;
    prevBtn.disabled = true; nextBtn.disabled = true; playBtn.disabled = true;
  }

  // Play control
  function startPlay(){
    if (!eventList || eventList.length === 0) return;
    if (playInterval) return;
    playBtn.textContent = 'Pause';
    const delay = Number(document.getElementById('speed') ? document.getElementById('speed').value : defaultSpeed);
    playInterval = setInterval(() => {
      if (currentStep >= eventList.length - 1) { stopPlay(); return; }
      nextStep();
    }, delay);
  }
  function stopPlay(){ if (playInterval){ clearInterval(playInterval); playInterval=null; playBtn.textContent='Play'; } }

  // Apply a single event forward
  function applyEvent(ev){
    if (!ev) return;
    if (ev.type === 'build-show'){
      const el = document.getElementById('node-' + ev.idx);
      if (el){ el.classList.remove('hidden'); el.classList.add('build-show'); buildShown[ev.idx]=true; }
      // highlight array slice
      highlightArrayRange(ev.l, ev.r, 'build-show');
      stepLog.innerHTML = `<div><strong>Build:</strong></div><small>Create node idx ${ev.idx} for range [${ev.l}, ${ev.r}] = ${ev.value}</small>`;
    } else if (ev.type === 'build-split'){
      // minor log to show split
      highlightArrayRange(ev.l, ev.mid, 'build-show');
      highlightArrayRange(ev.mid+1, ev.r, 'build-show');
      stepLog.innerHTML = `<div><strong>Build:</strong></div><small>Split node idx ${ev.idx} [${ev.l},${ev.r}] → [${ev.l},${ev.mid}] & [${ev.mid+1},${ev.r}]</small>`;
    } else if (ev.type === 'build-done'){
      stepLog.innerHTML = `<div><strong>Build:</strong></div><small>Finished node idx ${ev.idx} [${ev.l}, ${ev.r}] = ${ev.value}</small>`;
    } else if (ev.type === 'query-no'){
      const el = document.getElementById('node-' + ev.idx);
      if (el) { el.classList.add('skip'); }
      highlightArrayRange(ev.nodeRange[0], ev.nodeRange[1], 'skip');
      stepLog.innerHTML = `<div><strong>Query check:</strong></div><small>Node idx ${ev.idx} [${ev.nodeRange[0]},${ev.nodeRange[1]}] — <strong>no overlap</strong> with query</small>`;
    } else if (ev.type === 'query-partial'){
      const el = document.getElementById('node-' + ev.idx);
      if (el) { el.classList.add('partial'); }
      highlightArrayRange(ev.nodeRange[0], ev.nodeRange[1], 'partial');
      stepLog.innerHTML = `<div><strong>Query check:</strong></div><small>Node idx ${ev.idx} [${ev.nodeRange[0]},${ev.nodeRange[1]}] — <strong>partial overlap</strong>, recurse children</small>`;
    } else if (ev.type === 'query-full'){
      const el = document.getElementById('node-' + ev.idx);
      if (el) { el.classList.add('contrib'); }
      highlightArrayRange(ev.nodeRange[0], ev.nodeRange[1], 'contrib');
      // accumulate running total in the log
      stepLog.innerHTML = `<div><strong>Query add:</strong></div><small>Node idx ${ev.idx} [${ev.nodeRange[0]},${ev.nodeRange[1]}] fully inside query — add ${ev.value}</small>`;
    }
  }

  // Undo a single event (backwards)
  function undoEvent(ev){
    if (!ev) return;
    if (ev.type === 'build-show'){
      const el = document.getElementById('node-' + ev.idx);
      if (el){ el.classList.remove('build-show'); el.classList.add('hidden'); delete buildShown[ev.idx]; }
      clearArrayHighlights();
      stepLog.innerHTML = `<div><strong>Undo build:</strong></div><small>Remove node idx ${ev.idx} for range [${ev.l}, ${ev.r}]</small>`;
    } else if (ev.type === 'build-split'){
      // clear partial highlights
      clearArrayHighlights();
      stepLog.innerHTML = `<div><strong>Undo build split:</strong></div><small>Undo split info for node idx ${ev.idx}</small>`;
    } else if (ev.type === 'build-done'){
      stepLog.innerHTML = `<div><strong>Undo build done:</strong></div><small>Undo finished node idx ${ev.idx}</small>`;
    } else if (ev.type === 'query-no'){
      const el = document.getElementById('node-' + ev.idx);
      if (el) { el.classList.remove('skip'); }
      clearArrayHighlights();
      stepLog.innerHTML = `<div><strong>Undo query:</strong></div><small>Undo skip for node idx ${ev.idx}</small>`;
    } else if (ev.type === 'query-partial'){
      const el = document.getElementById('node-' + ev.idx);
      if (el) { el.classList.remove('partial'); }
      clearArrayHighlights();
      stepLog.innerHTML = `<div><strong>Undo query:</strong></div><small>Undo partial for node idx ${ev.idx}</small>`;
    } else if (ev.type === 'query-full'){
      const el = document.getElementById('node-' + ev.idx);
      if (el) { el.classList.remove('contrib'); }
      clearArrayHighlights();
      stepLog.innerHTML = `<div><strong>Undo query add:</strong></div><small>Undo contribution of node idx ${ev.idx}</small>`;
    }
  }

  function highlightArrayRange(l,r,cls){
    clearArrayHighlights();
    for (let i=l;i<=r;i++){
      const c = document.getElementById('cell-' + i);
      if (c){
        // use filter or outline depending on cls
        if (cls === 'contrib') c.style.boxShadow = '0 10px 30px rgba(16,185,129,0.18)';
        else if (cls === 'partial') c.style.boxShadow = '0 10px 30px rgba(245,158,11,0.12)';
        else if (cls === 'skip') c.style.filter = 'grayscale(.6) opacity(.7)';
        else if (cls === 'build-show') c.style.boxShadow = '0 10px 30px rgba(139,92,246,0.15)';
        c.style.transform = 'translateY(-4px)';
      }
    }
  }

  function clearArrayHighlights(){
    document.querySelectorAll('.cell').forEach(c => { c.style.boxShadow=''; c.style.filter=''; c.style.transform=''; });
  }

  // Step navigation
  function nextStep(){
    if (!eventList || currentStep >= eventList.length - 1) return;
    currentStep++;
    const ev = eventList[currentStep];
    applyEvent(ev);
    prevBtn.disabled = false;
    nextBtn.disabled = (currentStep >= eventList.length - 1);
    if (currentStep >= eventList.length - 1) playBtn.disabled = true;
  }

  function prevStep(){
    if (!eventList || currentStep < 0) return;
    const ev = eventList[currentStep];
    undoEvent(ev);
    currentStep--;
    prevBtn.disabled = (currentStep < 0);
    nextBtn.disabled = false;
    playBtn.disabled = false;
  }

  // UI wiring
  buildBtn.addEventListener('click', () => {
    const arr = parseArrayInput(arrayInput.value);
    if (!arr.length){ alert('Enter numbers separated by commas'); return; }
    currentArray = arr;
    renderArray(arr);
    tree = buildSegmentTree(arr);
    createTreeDOM(tree);
    resetStateAfterBuild();
  });

  function resetStateAfterBuild(){
    stopPlay();
    eventList = []; currentStep = -1;
    prevBtn.disabled = true; nextBtn.disabled = true; playBtn.disabled = true;
    stepLog.innerHTML = `<div><strong>Tree built:</strong></div><small>Tree DOM created and hidden. Click "Start Build Steps" to watch construction or record query.</small>`;
  }

  startBuildStepsBtn.addEventListener('click', () => {
    if (!tree){ alert('Build the tree first'); return; }
    stopPlay();
    // generate build events and load into eventList
    eventList = generateBuildEvents(tree);
    if (eventList.length===0){ alert('No build events'); return; }
    currentStep = -1;
    prevBtn.disabled = true; nextBtn.disabled = false; playBtn.disabled = false;
    // hide all nodes initially
    document.querySelectorAll('.node').forEach(n => { n.classList.add('hidden'); n.classList.remove('build-show','visited','partial','contrib','skip'); });
    clearArrayHighlights();
    stepLog.innerHTML = `<div><strong>Build steps recorded:</strong></div><small>${eventList.length} steps. Use Next to step through build.</small>`;
  });

  recordQueryBtn.addEventListener('click', () => {
    if (!tree){ alert('Build the tree first'); return; }
    stopPlay();
    // ensure build complete in DOM (we won't hide nodes that were shown during build)
    // generate query events
    const Lq = Number(ql.value), Rq = Number(qr.value);
    if (!Number.isInteger(Lq) || !Number.isInteger(Rq)){ alert('Enter integer l and r'); return; }
    const gen = generateQueryEvents(tree, Lq, Rq);
    if (!gen || !gen.events){ alert('Query gen error'); return; }
    // We want to run build events first if tree nodes are hidden
    // Prepend a small ensure-build-shown event for all nodes if none were shown
    const anyShown = document.querySelectorAll('.node:not(.hidden)').length > 0;
    if (!anyShown){
      // if build hasn't been done visually, remind user to run build steps or auto-show entire tree before query
      // We'll auto-show entire tree first (fast sequence)
      const showAll = [];
      for (let i=1;i<tree.length;i++){
        if (tree[i] && tree[i].start !== -1){
          showAll.push({ type:'build-show', idx:i, l:tree[i].start, r:tree[i].end, value:tree[i].value });
        }
      }
      // combine: showAll (quick) then query events
      eventList = showAll.concat(gen.events);
      stepLog.innerHTML = `<div><strong>Query recorded (auto-show tree first):</strong></div><small>${gen.events.length} query steps plus ${showAll.length} node reveals.</small>`;
    } else {
      eventList = gen.events;
      stepLog.innerHTML = `<div><strong>Query recorded:</strong></div><small>${gen.events.length} steps. Use Next to step through query mapping.</small>`;
    }
    // store meta for final summary
    eventList.meta = { L: Lq, R: Rq, result: gen.result };
    currentStep = -1; prevBtn.disabled = true; nextBtn.disabled = false; playBtn.disabled = false;
    // Reset highlights before query
    document.querySelectorAll('.node').forEach(n=>{ n.classList.remove('visited','partial','contrib','skip'); });
    clearArrayHighlights();
  });

  nextBtn.addEventListener('click', () => { stopPlay(); nextStep(); });
  prevBtn.addEventListener('click', () => { stopPlay(); prevStep(); });
  playBtn.addEventListener('click', () => {
    if (!eventList || eventList.length===0) return;
    if (playInterval){ stopPlay(); } else {
      playBtn.textContent='Pause'; const delay = defaultSpeed;
      playInterval = setInterval(() => {
        if (!eventList || currentStep >= eventList.length -1){ stopPlay(); return; }
        nextStep();
      }, delay);
    }
  });

  resetBtn.addEventListener('click', () => {
    stopPlay();
    // hide nodes but keep tree structure
    document.querySelectorAll('.node').forEach(n => {
      n.classList.add('hidden');
      n.classList.remove('build-show','visited','partial','contrib','skip');
    });
    clearArrayHighlights();
    eventList = []; currentStep = -1;
    prevBtn.disabled = true; nextBtn.disabled = true; playBtn.disabled = true;
    stepLog.innerHTML = `<div><strong>Reset:</strong></div><small>Visualization reset. You can restart build steps or record a query.</small>`;
  });

  // redraw connectors on resize/scroll
  window.addEventListener('resize', () => requestAnimationFrame(drawAllConnectors));
  document.getElementById('tree-panel').addEventListener('scroll', () => requestAnimationFrame(drawAllConnectors));

  // initial build
  buildBtn.click();

})();
</script>
</body>
</html>
